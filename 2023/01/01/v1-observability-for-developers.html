<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body>
<hr>
<p>layout: post
comments: true
description: Fix bugs before your user reports
categories: [observability]
last_modified_at: 2023-01-01T20:52:08.052481
last-modified-purpose:
permalink: /v1/observability-for-developers
title: Observability For Developers
—‌</p>

<h1 id="what-is-observability-and-why-is-it-needed">What is observability, and why is it needed?</h1>

<p>Observability are tools that help understand how an application is running.</p>

<p>Typically, one an application is deployed, it is treated like a black box. We don’t know what is happening inside the application except logs.</p>

<p>These logs aren’t good enough specially when considering the complex distributed applications we have.</p>

<p>The solution is to implement good observability.</p>

<p>Observability is also sometimes called testing-in-production. It allows for clearer insight into the application.</p>

<p>For example, let’s say you operate an e-commerce store and allow for multiple payment vendors like Google Pay, Amazon Pay, Apple Pay, etc. The code has been tested and working properly. Now, after an year, you went to buy something yourself. And you decided to use Apple Pay, but the payment fail. You debug and you find a critical configuration property was not added. Now you went ahead and fixed it. But when you check the database logs you realize, there wasn’t a single payment via Apple Pay for the last 1 year. You missed a lot of potential business there.</p>

<p>With observability, your flow to catch the bug would have looked something like this. You get alerts that the number of payment request failing is too high. You want into you dashboard and checked what is happening. It indeed seems too high. You check the logs and find the issue and fix it. You just saved yourself half and year.</p>

<p>With observability, you can be proactive about the bugs and about the optimizations you can make to your application before your customer reports it. This makes you a continuous improvement machine.</p>

<p>For a real life example, you can see Slack’s status which shows if slack is up or down. This provides an easy way for customers to know what is happening.</p>

<p><a href="https://status.slack.com/">https://status.slack.com/</a></p>

<h1 id="what-are-the-pillars-of-observability-and-why-do-they-make-sense">What are the pillars of observability, and why do they make sense?</h1>

<p>There are three main pillars of observability.</p>

<ol>
  <li>Metrics</li>
  <li>Logs</li>
  <li>Traces</li>
</ol>

<p>Metrics are numerical values related to the application in a moment. Like, CPU utilization, Number of HTTP Requests success or failures, and RAM Utilization.</p>

<p>Logs are the application logs. One must ensure that logs are properly added to the right log level. I wrote an article about the topic here: [Link to logs post]</p>

<p>Traces are the visualization of request flows between multiple microservices (MS). For example, MS1 triggered MS2, MS2 triggered MS3 and MS4.</p>

<h1 id="what-are-the-different-observability-tools">What are the different observability tools?</h1>

<p>There are different pieces involved in observability.</p>

<p><strong>Prometheus</strong>: [Link to Prometheus Article]</p>

<ul>
  <li>Tool for metrics.</li>
  <li>Application release logs in prometheus format.</li>
  <li>Prometheus will poll data every 15 minutes.</li>
  <li>It also allows to run queries against the data with use of PromQL language.</li>
  <li>
<strong>It’s important for developers to learn PromQL Language for debugging.</strong>.</li>
  <li>Developers can also add custom metrics via Prometheus.</li>
</ul>

<p><strong>OpenTelemetry</strong>:</p>

<ul>
  <li>A tool that adds traceId to requests and helps to track it across microservices.</li>
</ul>

<p><strong>Jaegar</strong>: A wrapper for open telemetry.</p>

<p><strong>Graphana</strong>: An active-development open-source tool for visualizing logs, metrics, traces and more.</p>

<p><strong>Kibana</strong>: Another popular tool for visualization. It’s part of a popular ELK stack.</p>

<p><strong>DataDog</strong>: A paid tool similar to Graphana.</p>

<h1 id="whats-the-architecture-of-graphana">What’s the architecture of Graphana?</h1>

<h1 id="what-are-the-basic-graphana-features-one-should-utilise">What are the basic Graphana features one should utilise?</h1>

<p>At the basic, one should be able to read logs. This is where most developers stop.</p>

<p>[Graphana Logs]</p>

<h1 id="how-to-set-up-dashboards-in-the-best-way">How to set up dashboards in the best way?</h1>

<p>The dashboard is where you’ll see all your metrics visualized.
You want to visualize it in such a way that you can get to the problems faster.</p>

<p>Make sure you segregate the most important metrics dashboard has only useful information</p>

<h1 id="how-to-set-up-alerts-in-the-best-way">How to set up alerts in the best way?</h1>

<p>Assume that most people don’t know what to do.</p>

<p>Your alert should provide:
Context: What happened exactly?
Next Step: What to do next?</p>

<h1 id="how-to-use-graphana-to-debug-a-scenario">How to use Graphana to debug a scenario?</h1>

<p>Here is what’s a typical flow:</p>

<ol>
  <li>You’ll get an alert</li>
  <li>You go to the dashboard and check it out.</li>
  <li>You try to explore more, you write custom queries to find more details.</li>
  <li>You combine the metrics with logs and traces.</li>
  <li>You find the problem and you take steps to fix it.</li>
</ol>

<p>Learn PromQL.</p>

<h1 id="how-can-chaos-engineering-help">How can Chaos Engineering help</h1>
</body></html>
